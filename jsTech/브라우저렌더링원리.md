Q. 브라우저 렌더링 과정에 대해 설명해보세요.

```
1. 제일먼저 html파일을 파싱하며 돔트리를 구성합니다 파싱중 HTML에 css가 포함되어 있다면 CSSOM 트리 구성작업도 함께 진행합니다.
또한 script 태그를 만나게 된다면 돔트리를 생성하는 과정을 잠시 중단하고 스크립트 태그 안에 있는 자바스크립트 코드를 해석하게 됩니다.

2. 그 뒤 돔트리와 CSSOM 트리를 합쳐서 렌더트리를 구성합니다. 렌더트리는 화면에 실제로 그려질 트리이며 화면에 표현되는 정보만 트리에 담기게 됩니다.

여기서 주의해야 할 점은 웹 접근성을 위해 텍스트를 숨겨야 할 때 display:none 과
같은 속성을 통해 태그를 숨겨버리면 렌더 트리안에 해당요소가 아예 들어가지 않기때문에 스크린리더기에서 해당 태그를 인식할 수 없는 문제가
발생하게 됩니다. 이를 위해서 접근성을 위해 텍스트를 숨겨야 할 때에는 display:none과 같은 속성을 쓰는 것을 지양하도록 합니다.

3. 그렇게 레이아웃 단계를 거치고 나면 페인트 단계에 돌입하여 지금까지 정보를 바탕으로 모든 시각적 부분을 그리는 작업을 진행합니다.

4. 그 뒤 컴포지팅 단계에서 각각의 레이어를 픽셀로 표현하고 레이어들을 합성해 페이지를 그리게 되면서 브라우저 렌더링과정이 완료됩니다.
```

Q. 페이지의 리플로우와 리페인트에 대해

```
브라우저는 html 구조상의 변화 혹은 스타일의 변화가 왔을 때 reflow, repaint라는 과정을 거치게됩니다.

우선 reflow는 주로 요소의 크기나 위치가 바뀌거나 브라우저 창의 크기가 바뀌었을 때 다시 발생합니다. 이때 영향을 받는 모든 노드의 수치를 다시 계산하고 렌더 트리를 재생성하는 과정을 거치게 됩니다. 리플로우가 일어나게 되면 페인트 단계도 필요해지므로 리페인트또한 발생하게 됩니다.
그렇기 때문에 reflow는 많은 비용을 발생시키며 최대한 reflow를 일으키지 않는 것이 좋습니다.

repaint는 reflow 과정이 끝난 후 재생성된 렌더트리를 다시 그리는 작업입니다.
여기서 수치와 상관없는 스타일만 변경이 될때에는 reflow 과정을 생략하고 repaint 작업만 수행하게 되므로 reflow보다는 성능상으로 조금 더 이점을 가집니다.
```

Q. reflow를 일으키지 않는것이 좋다고 했는데 어떤 방법이있는가?

```
css로 애니메이션을 구현할 때를 예로들어보겠습니다. 만약 position속성을 활용하여 애니메이션을 구현하게 된다면 브라우저는 매 프레임마다 reflow, repaint를 일으키게 됩니다. 이때 브라우저의 부담을 덜기위해 사용할 수 있는 속성 중에는 transform과 opacitiy가 있는데 이 두속성은 GPU 가속을 통해 실행되므로 성능상 이점을 가져올 수 있습니다.
따라서 css 애니메이션을 구현할 때는 transform속성을 활용하여 애니메이션을 구현해주면 성능적인 측면에서 많은 이점을 가질 수 있게 됩니다.

없어졌다 생기는 효과를 구현할때는 none - block 하면 리플로우 일으킴 근데 opacity를 쓰면 됨.
오파시티는 영역을 차지하고 있기 때문에 다시 렌더트리에 포함시키지않음. 왜냐면 이미 레이아웃에 포함이 되어있고 눈에만 안보임.
```
